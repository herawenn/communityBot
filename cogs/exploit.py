import os
import csv
import discord
import asyncio
import logging
from discord.ext import commands
from pathlib import Path
from helpers import send_and_delete, create_embed, is_valid_integer # type:ignore

logger = logging.getLogger(__name__)

class ExploitDB(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.root_dir = self.bot.config['paths']['root_directory']
        self.exploits_dir = self.bot.config['paths']['exploit_path']
        self.exploits_file = self.bot.config['paths']['exploit_file']
        self.delete_commands = self.bot.config['settings']['delete_commands']
        self.delete_command_delay = self.bot.config['settings']['delete_command_delay']
        self.delete_responses = self.bot.config['settings']['delete_responses']
        self.delete_response_delay = self.bot.config['settings']['delete_response_delay']
        self.delete_errors = self.bot.config['settings']['delete_errors']
        self.delete_errors_delay = self.bot.config['settings']['delete_errors_delay']
        self.categories = self.define_categories()
        self.exploits = self.load_exploits()

    def load_exploits(self):
        exploits = []
        try:
            logger.debug(f"Loading exploits from file: {self.exploits_file}")
            with open(self.exploits_file, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                for row in reader:
                    if '\x00' in row:
                        logger.error("An error occurred while loading exploits: line contains NUL")
                        continue
                    exploits.append(row)
        except Exception as e:
            logger.error(f"An error occurred while loading exploits: {e}", exc_info=True)
        return exploits

    def define_categories(self) -> dict:
        return {
            "Operating Systems": {
                "Windows": ["windows", "windows_x86", "windows_x86-64"],
                "Unix and Linux": ["linux", "linux_mips", "linux_sparc", "linux_x86", "linux_x86-64", "bsd", "bsd_x86", "freebsd", "freebsd_x86", "freebsd_x86-64", "netbsd_x86", "openbsd", "aix", "minix", "osx", "osx_ppc", "solaris", "solaris_sparc", "solaris_x86", "tru64", "ultrix", "unix", "unixware", "vxworks", "arm", "palm_os"],
                "Other Operating Systems": ["alpha", "atheos", "beos", "amigaos", "irix", "novell", "plan9", "qnx", "sco"]
            },
            "Programming Languages": {
                "Scripting": ["lua", "perl", "python", "ruby", "nodejs", "typescript", "cfm", "go"],
                "Web": ["asp", "aspx", "ashx", "cgi", "jsp", "php", "json", "xml"]
            }
        }

    @commands.command(name="categories", help="Lists all exploit categories.")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def list_categories(self, ctx):
        try:
            if not self.categories:
                await send_and_delete(ctx, content="`Error: No categories found.`", delay=self.delete_errors_delay, delete_type='error')
                return

            fields = []
            for main_category, sub_categories in self.categories.items():
                field_value = "\n".join([f"**`- {sub_cat}`** : `{', '.join(types)}`" for sub_cat, types in sub_categories.items()])
                fields.append((main_category, field_value, False))

            embed = create_embed(title="ExploitDB Categories",
                                  description="",
                                  color_key='primary',
                                  fields=fields,
                                  config=self.bot.config
                                  )
            await send_and_delete(ctx, embed=embed, delay=self.delete_response_delay)
            logger.info(f"List categories command executed successfully in {ctx.guild}")

            if self.delete_commands:
                await ctx.message.delete(delay=self.delete_command_delay)

        except Exception as e:
            logger.error(f"An error occurred in the list categories command: {e}", exc_info=True)
            await send_and_delete(ctx, content="`An error occurred while listing categories. Please try again later.`", delay=self.delete_errors_delay, delete_type='error')

    @list_categories.error
    async def list_categories_error(self, ctx, error):
        if isinstance(error, commands.CommandOnCooldown):
            retry_after = error.retry_after
            await send_and_delete(ctx, content=f"`This command is on cooldown. Please try again in {retry_after:.2f} seconds.`",
                                delay=self.bot.config['settings']['delete_errors_delay'],
                                delete_type='error')
        else:
            logger.error(f"Unexpected error occurred: {error}", exc_info=True)
            await send_and_delete(ctx, content="`An unexpected error occurred. Please try again later.`",
                                delay=self.bot.config['settings']['delete_errors_delay'],
                                delete_type='error')

    @commands.command(name="exploits", help="Searches for exploits by keyword. Usage: ..exploits <keyword>")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def search_exploits(self, ctx, *, keyword: str):
        try:
            if not keyword:
                await send_and_delete(ctx, content="`Error: Please provide a keyword to search for. Example: ..exploits wordpress`", delay=self.delete_errors_delay, delete_type='error')
                return

            results = [exploit for exploit in self.exploits if keyword.lower() in exploit['description'].lower()]
            if not results:
                await send_and_delete(ctx, content="`No exploits found for the given keyword.`", delay=self.delete_response_delay)
                return

            pages = self.paginate_exploits(results)
            current_page = 0
            embed = pages[current_page]
            message = await ctx.send(embed=embed)
            await message.add_reaction('◀️')
            await message.add_reaction('▶️')

            def check(reaction, user):
                return user == ctx.author and str(reaction.emoji) in ['◀️', '▶️']

            while True:
                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)
                    if str(reaction.emoji) == '◀️' and current_page > 0:
                        current_page -= 1
                    elif str(reaction.emoji) == '▶️' and current_page < len(pages) - 1:
                        current_page += 1
                    embed = pages[current_page]
                    await message.edit(embed=embed)
                    await message.remove_reaction(reaction, user)
                except asyncio.TimeoutError:
                    await message.clear_reactions()
                    break

            if self.delete_commands:
                await ctx.message.delete(delay=self.delete_command_delay)

            logger.info(f"Search exploits command executed successfully in {ctx.guild}")

        except Exception as e:
            logger.error(f"An error occurred in the search exploits command: {e}", exc_info=True)
            await send_and_delete(ctx, content="`An error occurred while searching for exploits. Please try again later.`", delay=self.delete_errors_delay, delete_type='error')

    @search_exploits.error
    async def search_exploits_error(self, ctx, error):
        if isinstance(error, commands.CommandOnCooldown):
            retry_after = error.retry_after
            await send_and_delete(ctx, content=f"`This command is on cooldown. Please try again in {retry_after:.2f} seconds.`",
                                delay=self.bot.config['settings']['delete_errors_delay'],
                                delete_type='error')
        else:
            logger.error(f"Unexpected error occurred: {error}", exc_info=True)
            await send_and_delete(ctx, content="`An unexpected error occurred. Please try again later.`",
                                delay=self.bot.config['settings']['delete_errors_delay'],
                                delete_type='error')

    @commands.command(name="download", help="Downloads a specific exploit by ID. Usage: ..download <exploit_id>")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def download_exploit(self, ctx, exploit_id: str):
        try:
            if not is_valid_integer(exploit_id):
                await send_and_delete(ctx, content="`Error: Please provide a valid exploit ID (an integer). Example: ..download 44645`", delay=self.delete_errors_delay, delete_type='error')
                return

            exploit_id = int(exploit_id)  # Convert to integer
            exploit = next((e for e in self.exploits if int(e['id']) == exploit_id), None)
            if not exploit:
                await send_and_delete(ctx, content="`Exploit not found.`", delay=self.delete_response_delay)
                return

            file_path_part = exploit['file']
            if file_path_part.startswith('exploits/'):
                file_path_part = file_path_part[len('exploits/'):]

            file_path = os.path.join(self.exploits_dir, file_path_part)

            if not os.path.exists(file_path):
                logger.error(f"Exploit file not found at path: {file_path}")
                await send_and_delete(ctx, content="`Exploit file not found.`", delay=self.delete_errors_delay, delete_type='error')
                return

            await send_and_delete(ctx, file=discord.File(file_path), delay=self.delete_response_delay)
            if self.delete_commands:
                await ctx.message.delete(delay=self.delete_command_delay)

            logger.info(f"Download exploit command executed successfully in {ctx.guild}")

        except Exception as e:
            logger.error(f"An error occurred in the download exploit command: {e}", exc_info=True)
            await send_and_delete(ctx, content="`An error occurred while downloading the exploit. Please try again later.`", delay=self.delete_errors_delay, delete_type='error')

    @download_exploit.error
    async def download_exploit_error(self, ctx, error):
        if isinstance(error, commands.CommandOnCooldown):
            retry_after = error.retry_after
            await send_and_delete(ctx, content=f"`This command is on cooldown. Please try again in {retry_after:.2f} seconds.`",
                                delay=self.bot.config['settings']['delete_errors_delay'],
                                delete_type='error')
        else:
            logger.error(f"Unexpected error occurred: {error}", exc_info=True)
            await send_and_delete(ctx, content="`An unexpected error occurred. Please try again later.`",
                                delay=self.bot.config['settings']['delete_errors_delay'],
                                delete_type='error')

    def paginate_exploits(self, exploits, items_per_page=5) -> list:
        pages = []
        for i in range(0, len(exploits), items_per_page):
            embed = create_embed(title="Exploit Search Results",
                                  description="",
                                  color_key='primary',
                                  config=self.bot.config
                                  )
            for exploit in exploits[i:i + items_per_page]:
                embed.add_field(name=exploit['id'], value=exploit['description'], inline=False)
            pages.append(embed)
        return pages

def setup(bot):
    bot.add_cog(ExploitDB(bot))
