import os
import csv
import discord
import asyncio
import logging
from discord.ext import commands

logger = logging.getLogger(__name__)

class ExploitDB(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.exploits_dir = 'exploits'
        self.exploits_file = 'exploits.csv'
        self.exploits = self.load_exploits()
        self.categories = self.define_categories()
        self.rate_limit = self.bot.config['settings']['rate_limit']
        self.delete_commands = self.bot.config['settings']['delete_commands']
        self.delete_responses = self.bot.config['settings']['delete_responses']
        self.delete_command_delay = self.bot.config['settings']['delete_command_delay']
        self.delete_response_delay = self.bot.config['settings']['delete_response_delay']

    def load_exploits(self):
        exploits = []
        try:
            with open(self.exploits_file, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                for row in reader:
                    if '\x00' in row:
                        logger.error("An error occurred while loading exploits: line contains NUL")
                        continue
                    exploits.append(row)
        except Exception as e:
            logger.error(f"An error occurred while loading exploits: {e}")
        return exploits

    def define_categories(self) -> dict:
        return {
            'Operating Systems': {
                'Windows': ['windows', 'windows_x86', 'windows_x86-64'],
                'Unix': {
                    'Linux': ['linux', 'linux_mips', 'linux_sparc', 'linux_x86', 'linux_x86-64'],
                    'BSD': ['bsd', 'bsd_x86', 'freebsd', 'freebsd_x86', 'freebsd_x86-64', 'netbsd_x86', 'openbsd'],
                    'Other Unix': ['aix','minix', 'osx', 'osx_ppc','solaris','solaris_sparc','solaris_x86', 'tru64', 'ultrix', 'unix', 'unixware', 'vxworks']
                },
                'Other OS': ['alpha', 'atheos', 'beos', 'immunix', 'irix', 'novell', 'plan9', 'qnx','sco']
            },
            'Scripting Languages': {
                'Dynamic Languages': ['lua', 'perl', 'python', 'ruby'],
                'JavaScript': ['nodejs', 'typescript'],
                'Other Scripting': ['cfm', 'go']
            },
            'Web Technologies': {
                'Microsoft Web': ['asp', 'aspx', 'ashx'],
                'Web Scripting': ['cgi', 'jsp', 'php'],
                'Data Formats': ['json', 'xml']
            },
            'Hardware and Miscellaneous': {
                'Hardware': ['arm', 'hardware', 'palm_os', 'multiple'],
            }
        }

    @commands.command(name="categories", help="Lists all exploit categories.")
    async def list_categories(self, ctx):
        logger.info(f"List categories command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not self.categories:
                error_message = await ctx.send("`No categories found.`")
                if self.delete_responses:
                    await asyncio.sleep(self.delete_response_delay)
                    await error_message.delete()
                return

            embed = discord.Embed(title="ExploitDB Categories", color=int(self.bot.config['embeds']['embed_colors']['primary'], 16))
            for main_category, sub_categories in self.categories.items():
                embed.add_field(name=main_category, value="\n".join([f"**`- {sub_cat}`** : `{', '.join(types)}`" for sub_cat, types in sub_categories.items()]), inline=False)

            message = await ctx.send(embed=embed)
            if self.delete_responses:
                await asyncio.sleep(self.delete_response_delay)
                await message.delete()

            logger.info(f"List categories command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the list categories command: {e}")
            error_message = await ctx.send("`An error occurred while listing categories. Please try again later.`")
            if self.delete_responses:
                await asyncio.sleep(self.delete_response_delay)
                await error_message.delete()

    @commands.command(name="exploits", help="Searches for exploits by keyword.")
    async def search_exploits(self, ctx, *, keyword: str):
        logger.info(f"Search exploits command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not keyword:
                error_message = await ctx.send("`Please provide a keyword to search for.`")
                if self.delete_responses:
                    await asyncio.sleep(self.delete_response_delay)
                    await error_message.delete()
                return

            results = [exploit for exploit in self.exploits if keyword.lower() in exploit['description'].lower()]
            if not results:
                error_message = await ctx.send("`No exploits found for the given keyword.`")
                if self.delete_responses:
                    await asyncio.sleep(self.delete_response_delay)
                    await error_message.delete()
                return

            pages = self.paginate_exploits(results)
            current_page = 0
            embed = pages[current_page]
            embed.color = int(self.bot.config['embeds']['embed_colors']['primary'], 16)
            message = await ctx.send(embed=embed)
            await message.add_reaction('◀️')
            await message.add_reaction('▶️')

            def check(reaction, user):
                return user == ctx.author and str(reaction.emoji) in ['◀️', '▶️']

            while True:
                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)
                    if str(reaction.emoji) == '◀️' and current_page > 0:
                        current_page -= 1
                    elif str(reaction.emoji) == '▶️' and current_page < len(pages) - 1:
                        current_page += 1
                    embed = pages[current_page]
                    embed.color = int(self.bot.config['embeds']['embed_colors']['primary'], 16)
                    await message.edit(embed=embed)
                    await message.remove_reaction(reaction, user)
                except asyncio.TimeoutError:
                    await message.clear_reactions()
                    break

            if self.delete_responses:
                await asyncio.sleep(self.delete_response_delay)
                await message.delete()

            logger.info(f"Search exploits command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the search exploits command: {e}")
            error_message = await ctx.send("`An error occurred while searching for exploits. Please try again later.`")
            if self.delete_responses:
                await asyncio.sleep(self.delete_response_delay)
                await error_message.delete()

    @commands.command(name="download", help="Downloads a specific exploit by ID.")
    async def download_exploit(self, ctx, exploit_id: int):
        logger.info(f"Download exploit command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not exploit_id:
                error_message = await ctx.send("`Please provide an exploit ID to download.`")
                if self.delete_responses:
                    await asyncio.sleep(self.delete_response_delay)
                    await error_message.delete()
                return

            exploit = next((e for e in self.exploits if int(e['id']) == exploit_id), None)
            if not exploit:
                error_message = await ctx.send("`Exploit not found.`")
                if self.delete_responses:
                    await asyncio.sleep(self.delete_response_delay)
                    await error_message.delete()
                return

            file_path = os.path.join(self.exploits_dir, exploit['file'])
            if not os.path.exists(file_path):
                error_message = await ctx.send("`Exploit file not found.`")
                if self.delete_responses:
                    await asyncio.sleep(self.delete_response_delay)
                    await error_message.delete()
                return

            file_message = await ctx.send(file=discord.File(file_path))
            if self.delete_responses:
                await asyncio.sleep(self.delete_response_delay)
                await ctx.message.delete()
                await asyncio.sleep(self.delete_response_delay)
                await file_message.delete()

            logger.info(f"Download exploit command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the download exploit command: {e}")
            error_message = await ctx.send("`An error occurred while downloading the exploit. Please try again later.`")
            if self.delete_responses:
                await asyncio.sleep(self.delete_response_delay)
                await error_message.delete()

    def paginate_exploits(self, exploits, items_per_page=5) -> list:
        pages = []
        for i in range(0, len(exploits), items_per_page):
            embed = discord.Embed(title="Exploit Search Results", color=discord.Color(0x6900ff))
            for exploit in exploits[i:i + items_per_page]:
                embed.add_field(name=exploit['id'], value=exploit['description'], inline=False)
            pages.append(embed)
        return pages

async def setup(bot):
    await bot.add_cog(ExploitDB(bot))
