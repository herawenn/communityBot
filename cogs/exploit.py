import os
import csv
import discord
import asyncio
import logging
from discord.ext import commands
from pathlib import Path
from helpers import send_and_delete

logger = logging.getLogger(__name__)

class ExploitDB(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.root_dir = self.bot.config['paths']['root_directory']
        self.exploits_dir = self.bot.config['paths']['exploit_path']
        self.exploits_file = self.bot.config['paths']['exploit_file']
        self.categories = self.define_categories()
        self.rate_limit = self.bot.config['settings']['rate_limit']
        self.delete_commands = self.bot.config['settings']['delete_commands']
        self.delete_responses = self.bot.config['settings']['delete_responses']
        self.delete_command_delay = self.bot.config['settings']['delete_command_delay']
        self.delete_response_delay = self.bot.config['settings']['delete_response_delay']
        self.delete_errors = self.bot.config['settings']['delete_errors']
        self.delete_errors_delay = self.bot.config['settings']['delete_errors_delay']
        self.exploits = self.load_exploits()
        self.exploit_channel_id = self.bot.config['identifiers']['exploit_channel_id']

    def load_exploits(self):
        exploits = []
        try:
            logger.debug(f"Loading exploits from file: {self.exploits_file}")
            with open(self.exploits_file, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                for row in reader:
                    if '\x00' in row:
                        logger.error("An error occurred while loading exploits: line contains NUL")
                        continue
                    exploits.append(row)
        except Exception as e:
            logger.error(f"An error occurred while loading exploits: {e}")
        return exploits

    def define_categories(self) -> dict:
        return {
            "Operating Systems": {
                "Windows": ["windows", "windows_x86", "windows_x86-64"],
                "Unix and Linux": ["linux", "linux_mips", "linux_sparc", "linux_x86", "linux_x86-64", "bsd", "bsd_x86", "freebsd", "freebsd_x86", "freebsd_x86-64", "netbsd_x86", "openbsd", "aix", "minix", "osx", "osx_ppc", "solaris", "solaris_sparc", "solaris_x86", "tru64", "ultrix", "unix", "unixware", "vxworks", "arm", "palm_os"],
                "Other Operating Systems": ["alpha", "atheos", "beos", "amigaos", "irix", "novell", "plan9", "qnx", "sco"]
            },
            "Programming Languages": {
                "Scripting": ["lua", "perl", "python", "ruby", "nodejs", "typescript", "cfm", "go"],
                "Web": ["asp", "aspx", "ashx", "cgi", "jsp", "php", "json", "xml"]
            }
        }

    @commands.command(name="categories", help="Lists all exploit categories.")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def list_categories(self, ctx):
        if ctx.channel.id != self.exploit_channel_id:
            await ctx.send(f"This command can only be used in <#{self.exploit_channel_id}>.")
            return

        logger.info(f"List categories command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not self.categories:
                await send_and_delete(ctx, "`Error: No categories found.`", delay=self.delete_errors_delay, delete_type='error')
                return

            embed = discord.Embed(title="ExploitDB Categories", color=int(self.bot.config['embeds']['embed_colors']['primary'], 16))
            for main_category, sub_categories in self.categories.items():
                embed.add_field(name=main_category, value="\n".join([f"**`- {sub_cat}`** : `{', '.join(types)}`" for sub_cat, types in sub_categories.items()]), inline=False)

            await send_and_delete(ctx, embed=embed, delay=self.delete_response_delay)
            logger.info(f"List categories command executed successfully in {ctx.guild}")

        except Exception as e:
            logger.error(f"An error occurred in the list categories command: {e}")
            await send_and_delete(ctx, "`An error occurred while listing categories. Please try again later.`", delay=self.delete_errors_delay, delete_type='error')

    @commands.command(name="exploits", help="Searches for exploits by keyword. Usage: ..exploits <keyword>")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def search_exploits(self, ctx, *, keyword: str):
        if ctx.channel.id != self.exploit_channel_id:
            await ctx.send(f"This command can only be used in <#{self.exploit_channel_id}>.")
            return

        logger.info(f"Search exploits command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not keyword:
                await send_and_delete(ctx, "`Error: Please provide a keyword to search for. Example: ..exploits wordpress`", delay=self.delete_errors_delay, delete_type='error')
                return

            results = [exploit for exploit in self.exploits if keyword.lower() in exploit['description'].lower()]
            if not results:
                await send_and_delete(ctx, "`No exploits found for the given keyword.`", delay=self.delete_response_delay)
                return

            pages = self.paginate_exploits(results)
            current_page = 0
            embed = pages[current_page]
            embed.color = int(self.bot.config['embeds']['embed_colors']['primary'], 16)
            message = await ctx.send(embed=embed)
            await message.add_reaction('◀️')
            await message.add_reaction('▶️')

            def check(reaction, user):
                return user == ctx.author and str(reaction.emoji) in ['◀️', '▶️']

            while True:
                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)
                    if str(reaction.emoji) == '◀️' and current_page > 0:
                        current_page -= 1
                    elif str(reaction.emoji) == '▶️' and current_page < len(pages) - 1:
                        current_page += 1
                    embed = pages[current_page]
                    embed.color = int(self.bot.config['embeds']['embed_colors']['primary'], 16)
                    await message.edit(embed=embed)
                    await message.remove_reaction(reaction, user)
                except asyncio.TimeoutError:
                    await message.clear_reactions()
                    break

            if self.delete_responses:
                await asyncio.sleep(self.delete_response_delay)
                await message.delete()

            logger.info(f"Search exploits command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the search exploits command: {e}")
            await send_and_delete(
                ctx,
                "`An error occurred while searching for exploits. Please try again later.`",
                delay=self.delete_errors_delay,
                delete_type='error')

    @commands.command(name="download", help="Downloads a specific exploit by ID. Usage: ..download <exploit_id>")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def download_exploit(self, ctx, exploit_id: int):
        if ctx.channel.id != self.exploit_channel_id:
            await ctx.send(f"This command can only be used in <#{self.exploit_channel_id}>.")
            return

        logger.info(f"Download exploit command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not exploit_id:
                await send_and_delete(ctx, "`Error: Please provide an exploit ID to download. Example: ..download 44645`", delay=self.delete_errors_delay, delete_type='error')
                return

            exploit = next((e for e in self.exploits if int(e['id']) == exploit_id), None)
            if not exploit:
                await send_and_delete(ctx, "`Exploit not found.`", delay=self.delete_response_delay)
                return

            file_path_part = exploit['file']
            if file_path_part.startswith('exploits/'):
                file_path_part = file_path_part[len('exploits/'):]

            file_path = os.path.join(self.exploits_dir, file_path_part)

            if not os.path.exists(file_path):
                logger.error(f"Exploit file not found at path: {file_path}")
                await send_and_delete(ctx, "`Exploit file not found.`", delay=self.delete_errors_delay, delete_type='error')
                return

            await send_and_delete(ctx, file=discord.File(file_path), delay=self.delete_response_delay)

            logger.info(f"Download exploit command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the download exploit command: {e}")
            await send_and_delete(ctx, "`An error occurred while downloading the exploit. Please try again later.`", delay=self.delete_errors_delay, delete_type='error')

    def paginate_exploits(self, exploits, items_per_page=5) -> list:
        pages = []
        for i in range(0, len(exploits), items_per_page):
            embed = discord.Embed(title="Exploit Search Results", color=int(self.bot.config['embeds']['embed_colors']['primary'], 16))
            for exploit in exploits[i:i + items_per_page]:
                embed.add_field(name=exploit['id'], value=exploit['description'], inline=False)
            pages.append(embed)
        return pages

async def setup(bot):
    await bot.add_cog(ExploitDB(bot))
