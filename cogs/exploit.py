import os
import csv
import discord
import asyncio
import logging
from discord.ext import commands

logger = logging.getLogger(__name__)

class ExploitDB(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.exploits_dir = 'exploits'
        self.exploits_file = 'exploits.csv'
        self.exploits = self.load_exploits()
        self.categories = self.define_categories()

    def load_exploits(self):
        exploits = []
        try:
            with open(self.exploits_file, mode='r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                for row in reader:
                    exploits.append(row)
        except Exception as e:
            logger.error(f"An error occurred while loading exploits: {e}")
        return exploits

    def define_categories(self) -> dict:
        return {
            'Windows': ['windows', 'windows_x86', 'windows_x86-64'],
            'Scripting': ['lua', 'perl', 'python', 'nodejs', 'ruby', 'typescript'],
            'Web': ['asp', 'aspx', 'cgi', 'json', 'jsp', 'php', 'xml'],
            'Unix': ['aix', 'bsd', 'bsd_x86', 'freebsd', 'freebsd_x86', 'freebsd_x86-64', 'linux', 'linux_mips', 'linux_sparc', 'linux_x86', 'linux_x86-64', 'minix', 'netbsd_x86', 'openbsd', 'osx', 'osx_ppc', 'solaris', 'solaris_sparc', 'solaris_x86', 'tru64', 'ultrix', 'unix', 'unixware', 'vxworks'],
            'Other': ['alpha', 'arm', 'ashx', 'atheos', 'beos', 'cfm', 'go', 'immunix', 'irix', 'java', 'novell', 'plan9', 'qnx', 'sco', 'palm_os', 'multiple', 'hardware']
        }

    @commands.command(name="categories", help="List all exploit categories.")
    async def categories(self, ctx):
        logger.info(f"List categories command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not self.categories:
                await ctx.send("No categories found.")
                return
            embed = discord.Embed(title="ExploitDB Categories", color=discord.Color(0x6900ff))
            for category, types in self.categories.items():
                embed.add_field(name=category, value=", ".join(types), inline=False)
            await ctx.send(embed=embed)
            logger.info(f"List categories command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the list categories command: {e}")
            await ctx.send("An error occurred while listing categories. Please try again later.")

    @commands.command(name="exploit", help="Search for exploits by keyword.")
    async def exploit(self, ctx, *, keyword: str):
        logger.info(f"Search exploits command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not keyword:
                await ctx.send("Please provide a keyword to search for.")
                return
            results = [exploit for exploit in self.exploits if keyword.lower() in exploit['description'].lower()]
            if not results:
                await ctx.send("No exploits found for the given keyword.")
                return

            pages = self.paginate_exploits(results)
            current_page = 0
            message = await ctx.send(embed=pages[current_page])
            await message.add_reaction('◀️')
            await message.add_reaction('▶️')

            def check(reaction, user):
                return user == ctx.author and str(reaction.emoji) in ['◀️', '▶️']

            while True:
                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)
                    if str(reaction.emoji) == '◀️' and current_page > 0:
                        current_page -= 1
                    elif str(reaction.emoji) == '▶️' and current_page < len(pages) - 1:
                        current_page += 1
                    await message.edit(embed=pages[current_page])
                    await message.remove_reaction(reaction, user)
                except asyncio.TimeoutError:
                    await message.clear_reactions()
                    break

            logger.info(f"Search exploits command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the search exploits command: {e}")
            await ctx.send("An error occurred while searching for exploits. Please try again later.")

    @commands.command(name="download", help="Download a specific exploit by ID.")
    async def download(self, ctx, exploit_id: int):
        logger.info(f"Download exploit command invoked by {ctx.author} in {ctx.guild}")
        try:
            if not exploit_id:
                await ctx.send("Please provide an exploit ID to download.")
                return
            exploit = next((e for e in self.exploits if int(e['id']) == exploit_id), None)
            if not exploit:
                await ctx.send("Exploit not found.")
                return

            file_path = exploit['file']
            if not os.path.exists(file_path):
                await ctx.send("Exploit file not found.")
                return

            await ctx.send(file=discord.File(file_path))
            logger.info(f"Download exploit command executed successfully in {ctx.guild}")
        except Exception as e:
            logger.error(f"An error occurred in the download exploit command: {e}")
            await ctx.send("An error occurred while downloading the exploit. Please try again later.")

    def paginate_exploits(self, exploits, items_per_page=5):
        pages = []
        for i in range(0, len(exploits), items_per_page):
            embed = discord.Embed(title="Exploit Search Results", color=discord.Color(0x6900ff))
            for exploit in exploits[i:i + items_per_page]:
                embed.add_field(name=exploit['id'], value=exploit['description'], inline=False)
            pages.append(embed)
        return pages

async def setup(bot):
    await bot.add_cog(ExploitDB(bot))
